<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Regions &#8212; NuPIC 0.5.8.dev0
 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5.8.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Sensors" href="network-sensors.html" />
    <link rel="prev" title="Network" href="network-network.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nupic.regions">
<span id="regions"></span><h1>Regions<a class="headerlink" href="#module-nupic.regions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="pyregion">
<h2>PyRegion<a class="headerlink" href="#pyregion" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.bindings.regions.PyRegion.PyRegion">
<em class="property">class </em><code class="descclassname">nupic.bindings.regions.PyRegion.</code><code class="descname">PyRegion</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwars</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>PyRegion provides services to its sub-classes (the actual regions):</p>
<ul class="simple">
<li>Define and document the interface of a Python region</li>
<li>Enforce implementation of required methods</li>
<li>Default implementation for some methods</li>
</ul>
<p>PyRegion is an abstract base class (<a class="reference external" href="http://docs.python.org/library/abc.html">http://docs.python.org/library/abc.html</a>).
If a subclass doesn&#8217;t implement all its abstract methods it can&#8217;t be
instantiated. Note, that the signature of implemented abstract method in the
subclass doesn&#8217;t need to match the signature of the abstract method in the
base class. This is very important for __init__() in this case.</p>
<p>The abstract methods (decorated with &#64;abstract method) are:</p>
<ul class="simple">
<li>__init__</li>
<li>initialize</li>
<li>compute</li>
</ul>
<p>In addition, some PyRegion methods raise NotImplementedError which throws
an exception if called. A sub-class may opt not to implement these
methods, but if such a methods is called then a NotImplementedError will be
raised. This is useful for methods like setParameterArray if a particular
subclass has no array parameters.</p>
<p>The not implemented methods are:</p>
<ul class="simple">
<li>getSpec (class method)</li>
<li>setParameter</li>
<li>setParameterArray</li>
<li>getOutputElementCount</li>
</ul>
<p>The getSpec is a class method, which is actually required but since it&#8217;s
not an instance method the &#64;abstractmethod decorator doesn&#8217;t apply.</p>
<p>Finally, PyRegion provides reasonable default implementation to some methods.
Sub-classes may opt to override these methods or use the default
implementation (often recommended).</p>
<p>The implemented methods are:</p>
<ul class="simple">
<li>getParameter</li>
<li>getParameterArray</li>
<li>getParameterArrayCount</li>
<li>executeMethod</li>
</ul>
<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em>inputs</em>, <em>outputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the main computation</p>
<p>This method is called in each iteration for each phase the node supports.</p>
<p>inputs: dict of numpy arrays (one per input)
outputs: dict of numpy arrays (one per output)</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.deSerializeExtraData">
<code class="descname">deSerializeExtraData</code><span class="sig-paren">(</span><em>filePath</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.deSerializeExtraData" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called during network deserialization with an external
filename that can be used to bypass pickle for loading large binary states.</p>
<p>filePath: full filepath and name</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.executeMethod">
<code class="descname">executeMethod</code><span class="sig-paren">(</span><em>methodName</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.executeMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a method named &#8216;methodName&#8217; with the specified arguments.</p>
<p>This method is called when the user executes a command as defined in
the node spec. It provides a perfectly reasonble implementation
of the command mechanism. As a sub-class developer you just need to
implement a method for each command in the node spec. Note that due to
the command mechanism only unnamed argument are supported.</p>
<p>methodName: the name of the method that correspond to a command in the spec
args: list of arguments that will be passed to the method</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.getOutputElementCount">
<code class="descname">getOutputElementCount</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.getOutputElementCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of elements in the output of a single node</p>
<p>If the region has multiple nodes (all must have the same output
size) then just the number of output elements of a single node
should be returned.</p>
<p>name: the name of the output</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.getParameter">
<code class="descname">getParameter</code><span class="sig-paren">(</span><em>name</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.getParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implementation that return an attribute with the requested name</p>
<p>This method provides a default implementation of getParameter() that simply
returns an attribute with the parameter name. If the Region conceptually
contains multiple nodes with separate state the &#8216;index&#8217; argument is used
to request a parameter of a specific node inside the region. In case of
a region-level parameter the index should be -1</p>
<p>The implementation prevents accessing parameters names that start with &#8216;_&#8217;.
It may be better to enforce this convention at the node spec level.</p>
<p>name: name of requested parameter
index: index of node inside the region (if relevant)</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.getParameterArray">
<code class="descname">getParameterArray</code><span class="sig-paren">(</span><em>name</em>, <em>index</em>, <em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.getParameterArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implementation that return an attribute with the requested name</p>
<p>This method provides a default implementation of getParameterArray() that
returns an attribute with the parameter name. If the Region conceptually
contains multiple nodes with separate state the &#8216;index&#8217; argument is used
to request a parameter of a specific node inside the region. The attribute
value is written into the output array. No type or sanity checks are
performed for performance reasons. If something goes awry it will result
in a low-level exception. If you are unhappy about it you can implement
your own getParameterArray() method in the subclass.</p>
<p>The implementation prevents accessing parameters names that start with &#8216;_&#8217;.
It may be better to enforce this convention at the node spec level.</p>
<p>name: name of requested parameter
index: index of node inside the region (if relevant)
array: output numpy array that the value is written to</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.getParameterArrayCount">
<code class="descname">getParameterArrayCount</code><span class="sig-paren">(</span><em>name</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.getParameterArrayCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implementation that return the length of the attribute</p>
<p>This default implementation goes hand in hand with getParameterArray().
If you override one of them in your subclass, you should probably override
both of them.</p>
<p>The implementation prevents accessing parameters names that start with &#8216;_&#8217;.
It may be better to enforce this convention at the node spec level.</p>
<p>name: name of requested parameter
index: index of node inside the region (if relevant)</p>
</dd></dl>

<dl class="staticmethod">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.getProtoType">
<em class="property">static </em><code class="descname">getProtoType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.getProtoType" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pycapnp proto type that the class uses for serialization.</p>
<p>This is used to convert the proto into the proper type before passing it
into the read or write method of the subclass.</p>
</dd></dl>

<dl class="classmethod">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.getSpec">
<em class="property">classmethod </em><code class="descname">getSpec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.getSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the region spec for this region. The Region Spec is a dictionary
with the following keys:
description &#8211; a string</p>
<p>singleNodeOnly &#8211; a boolean (True if this Region supports only a single node)</p>
<p>inputs &#8211; a dictionary in which the keys are the names of the inputs and
the values are dictionaries with these keys:</p>
<blockquote>
<div>description - string
regionLevel &#8211; True if this is a &#8220;region-level&#8221; input.
dataType - a string describing the data type, usually &#8216;Real32&#8217;
count - the number of items in the input. 0 means unspecified.
required &#8211; boolean - whether the input is must be connected
isDefaultInput &#8211; must be True for exactly one input
requireSplitterMap &#8211; [just set this to False.]</div></blockquote>
<p>outputs &#8211; a dictionary with similar structure to inputs. The keys
are:</p>
<blockquote>
<div>description
dataType
count
regionLevel
isDefaultOutput</div></blockquote>
<dl class="docutils">
<dt>parameters &#8211; a dictionary of dictionaries with the following keys:</dt>
<dd>description
dataType
count
constraints (optional)
accessMode (one of &#8220;ReadWrite&#8221;, &#8220;Read&#8221;, &#8220;Create&#8221;)</dd>
</dl>
<p>This class method is called by NuPIC before creating a Region.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.guardedCompute">
<code class="descname">guardedCompute</code><span class="sig-paren">(</span><em>inputs</em>, <em>outputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.guardedCompute" title="Permalink to this definition">¶</a></dt>
<dd><p>The C++ entry point to compute.</p>
<p>inputs: dict of numpy arrays (one per input)
outputs: dict of numpy arrays (one per output)</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>inputs</em>, <em>outputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the node after the network is fully linked</p>
<p>It is called once by NuPIC before the first call to compute(). It is
a good place to perform one time initialization that depend on the inputs
and/or outputs. The region may also remember its inputs and outputs here
because they will not change.</p>
<p>inputs: dict of numpy arrays (one per input)
outputs: dict of numpy arrays (one per output)</p>
</dd></dl>

<dl class="classmethod">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.read">
<em class="property">classmethod </em><code class="descname">read</code><span class="sig-paren">(</span><em>proto</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls readFromProto on subclass after converting proto to specific type
using getProtoType().</p>
<p>proto: PyRegionProto capnproto object</p>
</dd></dl>

<dl class="classmethod">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.readFromProto">
<em class="property">classmethod </em><code class="descname">readFromProto</code><span class="sig-paren">(</span><em>proto</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.readFromProto" title="Permalink to this definition">¶</a></dt>
<dd><p>Read state from proto object.</p>
<p>The type of proto is determined by getProtoType().</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.serializeExtraData">
<code class="descname">serializeExtraData</code><span class="sig-paren">(</span><em>filePath</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.serializeExtraData" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called during network serialization with an external
filename that can be used to bypass pickle for saving large binary states.</p>
<p>filePath: full filepath and name</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.setParameter">
<code class="descname">setParameter</code><span class="sig-paren">(</span><em>name</em>, <em>index</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.setParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of a parameter</p>
<p>If the Region conceptually contains multiple nodes with separate state
the &#8216;index&#8217; argument is used set a parameter of a specific node inside
the region.</p>
<p>name: name of requested parameter
index: index of node inside the region (if relevant)
value: the value to assign to the requested parameter</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.setParameterArray">
<code class="descname">setParameterArray</code><span class="sig-paren">(</span><em>name</em>, <em>index</em>, <em>array</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.setParameterArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of an array parameter</p>
<p>If the Region conceptually contains multiple nodes with separate state
the &#8216;index&#8217; argument is used set a parameter of a specific node inside
the region.</p>
<p>name: name of requested parameter
index: index of node inside the region (if relevant)
array: the value to assign to the requested parameter (a numpy array)</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>proto</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls writeToProto on subclass after converting proto to specific type
using getProtoType().</p>
<p>proto: PyRegionProto capnproto object</p>
</dd></dl>

<dl class="method">
<dt id="nupic.bindings.regions.PyRegion.PyRegion.writeToProto">
<code class="descname">writeToProto</code><span class="sig-paren">(</span><em>proto</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.bindings.regions.PyRegion.PyRegion.writeToProto" title="Permalink to this definition">¶</a></dt>
<dd><p>Write state to proto object.</p>
<p>The type of proto is determined by getProtoType().</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="anomalyregion">
<h2>AnomalyRegion<a class="headerlink" href="#anomalyregion" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.regions.AnomalyRegion.AnomalyRegion">
<em class="property">class </em><code class="descclassname">nupic.regions.AnomalyRegion.</code><code class="descname">AnomalyRegion</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.AnomalyRegion.AnomalyRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.bindings.regions.PyRegion.PyRegion" title="nupic.bindings.regions.PyRegion.PyRegion"><code class="xref py py-class docutils literal"><span class="pre">nupic.bindings.regions.PyRegion.PyRegion</span></code></a></p>
<p>Region for computing the anomaly score.</p>
</dd></dl>

</div>
<div class="section" id="spregion">
<h2>SPRegion<a class="headerlink" href="#spregion" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.regions.SPRegion.SPRegion">
<em class="property">class </em><code class="descclassname">nupic.regions.SPRegion.</code><code class="descname">SPRegion</code><span class="sig-paren">(</span><em>columnCount</em>, <em>inputWidth</em>, <em>spatialImp='cpp'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SPRegion.SPRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.bindings.regions.PyRegion.PyRegion" title="nupic.bindings.regions.PyRegion.PyRegion"><code class="xref py py-class docutils literal"><span class="pre">nupic.bindings.regions.PyRegion.PyRegion</span></code></a></p>
<p>SPRegion is designed to implement the spatial pooler compute for a given
HTM level.</p>
<p>Uses the SpatialPooler class to do most of the work. This node has just one
SpatialPooler instance for the enitire level and does <em>not</em> support the concept
of &#8220;baby nodes&#8221; within it.</p>
<p>Automatic parameter handling:</p>
<p>Parameter names, default values, and descriptions are retrieved automatically
from SpatialPooler. Thus, there are only a few hardcoded arguments in __init__,
and the rest are passed to the appropriate underlying class. The NodeSpec is
mostly built automatically from these parameters, too.</p>
<p>If you add a parameter to SpatialPooler, it will be exposed through SPRegion
automatically as if it were in SPRegion.__init__, with the right default
value. Add an entry in the __init__ docstring for it too, and that will be
brought into the NodeSpec. SPRegion will maintain the parameter as its own
instance variable and also pass it to SpatialPooler. If the parameter is
changed, SPRegion will propagate the change.</p>
<p>If you want to do something different with the parameter, add it as an
argument into SPRegion.__init__, which will override all the default handling.</p>
<dl class="method">
<dt id="nupic.regions.SPRegion.SPRegion.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em>inputs</em>, <em>outputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SPRegion.SPRegion.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one iteration of SPRegion&#8217;s compute, profiling it if requested.</p>
<p>The guts of the compute are contained in the _compute() call so that
we can profile it if requested.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.SPRegion.SPRegion.getAlgorithmInstance">
<code class="descname">getAlgorithmInstance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SPRegion.SPRegion.getAlgorithmInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns instance of the underlying SpatialPooler algorithm object.</p>
</dd></dl>

<dl class="classmethod">
<dt id="nupic.regions.SPRegion.SPRegion.getBaseSpec">
<em class="property">classmethod </em><code class="descname">getBaseSpec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SPRegion.SPRegion.getBaseSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the base Spec for SPRegion.</p>
<p>Doesn&#8217;t include the spatial, temporal and other parameters</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.SPRegion.SPRegion.getParameter">
<code class="descname">getParameter</code><span class="sig-paren">(</span><em>parameterName</em>, <em>index=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SPRegion.SPRegion.getParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of a NodeSpec parameter. Most parameters are handled
automatically by PyRegion&#8217;s parameter get mechanism. The ones that need
special treatment are explicitly handled here.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="nupic.regions.SPRegion.SPRegion.getProtoType">
<em class="property">static </em><code class="descname">getProtoType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SPRegion.SPRegion.getProtoType" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pycapnp proto type that the class uses for serialization.</p>
</dd></dl>

<dl class="classmethod">
<dt id="nupic.regions.SPRegion.SPRegion.getSpec">
<em class="property">classmethod </em><code class="descname">getSpec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SPRegion.SPRegion.getSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Spec for SPRegion.</p>
<p>The parameters collection is constructed based on the parameters specified
by the variosu components (spatialSpec, temporalSpec and otherSpec)</p>
</dd></dl>

<dl class="classmethod">
<dt id="nupic.regions.SPRegion.SPRegion.readFromProto">
<em class="property">classmethod </em><code class="descname">readFromProto</code><span class="sig-paren">(</span><em>proto</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SPRegion.SPRegion.readFromProto" title="Permalink to this definition">¶</a></dt>
<dd><p>Read state from proto object.</p>
<p>proto: SPRegionProto capnproto object</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.SPRegion.SPRegion.setParameter">
<code class="descname">setParameter</code><span class="sig-paren">(</span><em>parameterName</em>, <em>index</em>, <em>parameterValue</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SPRegion.SPRegion.setParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of a Spec parameter. Most parameters are handled
automatically by PyRegion&#8217;s parameter set mechanism. The ones that need
special treatment are explicitly handled here.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.SPRegion.SPRegion.writeToProto">
<code class="descname">writeToProto</code><span class="sig-paren">(</span><em>proto</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SPRegion.SPRegion.writeToProto" title="Permalink to this definition">¶</a></dt>
<dd><p>Write state to proto object.</p>
<p>proto: SPRegionProto capnproto object</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tpregion">
<h2>TPRegion<a class="headerlink" href="#tpregion" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.regions.TPRegion.TPRegion">
<em class="property">class </em><code class="descclassname">nupic.regions.TPRegion.</code><code class="descname">TPRegion</code><span class="sig-paren">(</span><em>columnCount</em>, <em>inputWidth</em>, <em>cellsPerColumn</em>, <em>orColumnOutputs=False</em>, <em>cellsSavePath=''</em>, <em>temporalImp='py'</em>, <em>anomalyMode=False</em>, <em>computePredictedActiveCellIndices=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.TPRegion.TPRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.bindings.regions.PyRegion.PyRegion" title="nupic.bindings.regions.PyRegion.PyRegion"><code class="xref py py-class docutils literal"><span class="pre">nupic.bindings.regions.PyRegion.PyRegion</span></code></a></p>
<p>TPRegion is designed to implement the temporal pooler compute for a given
CLA level.</p>
<p>Uses a subclass of TP to do most of the work. The specific TP implementation
is specified using the temporalImp parameter.</p>
<p>Automatic parameter handling:</p>
<p>Parameter names, default values, and descriptions are retrieved automatically
from the temporal pooler class. Thus, there are only a few hardcoded
arguments in __init__, and the rest are passed to the appropriate underlying
class. The RegionSpec is mostly built automatically from these parameters.</p>
<p>If you add a parameter to a TP class, it will be exposed through TPRegion
automatically as if it were in TPRegion.__init__, with the right default
value. Add an entry in the __init__ docstring for it too, and that will be
brought into the RegionSpec. TPRegion will maintain the parameter as its own
instance variable and also pass it to the temporal pooler instance. If the
parameter is changed, TPRegion will propagate the change.</p>
<p>If you want to do something different with the parameter, add it as an
argument into TPRegion.__init__, which will override all the default handling.</p>
<dl class="method">
<dt id="nupic.regions.TPRegion.TPRegion.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em>inputs</em>, <em>outputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.TPRegion.TPRegion.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one iteration of TPRegion&#8217;s compute, profiling it if requested.</p>
<p>The guts of the compute are contained in the _compute() call so that
we can profile it if requested.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.TPRegion.TPRegion.deSerializeExtraData">
<code class="descname">deSerializeExtraData</code><span class="sig-paren">(</span><em>filePath</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.TPRegion.TPRegion.deSerializeExtraData" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called during network deserialization with an external
filename that can be used to bypass pickle for loading large binary states.</p>
<p>filePath: full filepath and name</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.TPRegion.TPRegion.finishLearning">
<code class="descname">finishLearning</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.TPRegion.TPRegion.finishLearning" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an internal optimization step that speeds up inference if we know
learning will not be performed anymore. This call may, for example, remove
all potential inputs to each column.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.TPRegion.TPRegion.getAlgorithmInstance">
<code class="descname">getAlgorithmInstance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.TPRegion.TPRegion.getAlgorithmInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns instance of the underlying TemporalMemory algorithm object.</p>
</dd></dl>

<dl class="classmethod">
<dt id="nupic.regions.TPRegion.TPRegion.getBaseSpec">
<em class="property">classmethod </em><code class="descname">getBaseSpec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.TPRegion.TPRegion.getBaseSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the base Spec for TPRegion.</p>
<p>Doesn&#8217;t include the spatial, temporal and other parameters</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.TPRegion.TPRegion.getParameter">
<code class="descname">getParameter</code><span class="sig-paren">(</span><em>parameterName</em>, <em>index=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.TPRegion.TPRegion.getParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of a parameter. Most parameters are handled automatically by
PyRegion&#8217;s parameter get mechanism. The ones that need special treatment
are explicitly handled here.</p>
</dd></dl>

<dl class="classmethod">
<dt id="nupic.regions.TPRegion.TPRegion.getSpec">
<em class="property">classmethod </em><code class="descname">getSpec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.TPRegion.TPRegion.getSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Spec for TPRegion.</p>
<p>The parameters collection is constructed based on the parameters specified
by the variosu components (spatialSpec, temporalSpec and otherSpec)</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.TPRegion.TPRegion.resetSequenceStates">
<code class="descname">resetSequenceStates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.TPRegion.TPRegion.resetSequenceStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the region&#8217;s sequence states</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.TPRegion.TPRegion.serializeExtraData">
<code class="descname">serializeExtraData</code><span class="sig-paren">(</span><em>filePath</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.TPRegion.TPRegion.serializeExtraData" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called during network serialization with an external
filename that can be used to bypass pickle for saving large binary states.</p>
<p>filePath: full filepath and name</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.TPRegion.TPRegion.setParameter">
<code class="descname">setParameter</code><span class="sig-paren">(</span><em>parameterName</em>, <em>index</em>, <em>parameterValue</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.TPRegion.TPRegion.setParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of a Spec parameter. Most parameters are handled
automatically by PyRegion&#8217;s parameter set mechanism. The ones that need
special treatment are explicitly handled here.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="anomalylikelihoodregion">
<h2>AnomalyLikelihoodRegion<a class="headerlink" href="#anomalylikelihoodregion" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.regions.AnomalyLikelihoodRegion.AnomalyLikelihoodRegion">
<em class="property">class </em><code class="descclassname">nupic.regions.AnomalyLikelihoodRegion.</code><code class="descname">AnomalyLikelihoodRegion</code><span class="sig-paren">(</span><em>learningPeriod=288</em>, <em>estimationSamples=100</em>, <em>historicWindowSize=8640</em>, <em>reestimationPeriod=100</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.AnomalyLikelihoodRegion.AnomalyLikelihoodRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.bindings.regions.PyRegion.PyRegion" title="nupic.bindings.regions.PyRegion.PyRegion"><code class="xref py py-class docutils literal"><span class="pre">nupic.bindings.regions.PyRegion.PyRegion</span></code></a></p>
<p>Region for computing the anomaly likelihoods.</p>
</dd></dl>

</div>
<div class="section" id="claclassifierregion">
<h2>CLAClassifierRegion<a class="headerlink" href="#claclassifierregion" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.regions.CLAClassifierRegion.CLAClassifierRegion">
<em class="property">class </em><code class="descclassname">nupic.regions.CLAClassifierRegion.</code><code class="descname">CLAClassifierRegion</code><span class="sig-paren">(</span><em>steps='1'</em>, <em>alpha=0.001</em>, <em>verbosity=0</em>, <em>implementation=None</em>, <em>maxCategoryCount=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.CLAClassifierRegion.CLAClassifierRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.bindings.regions.PyRegion.PyRegion" title="nupic.bindings.regions.PyRegion.PyRegion"><code class="xref py py-class docutils literal"><span class="pre">nupic.bindings.regions.PyRegion.PyRegion</span></code></a></p>
<p>CLAClassifierRegion implements a CLA specific classifier that accepts a binary
input from the level below (the &#8220;activationPattern&#8221;) and information from the
sensor and encoders (the &#8220;classification&#8221;) describing the input to the system
at that time step.</p>
<p>When learning, for every bit in activation pattern, it records a history of 
the classification each time that bit was active. The history is bounded by a
maximum allowed age so that old entries are thrown away.</p>
<p>For inference, it takes an ensemble approach. For every active bit in the
activationPattern, it looks up the most likely classification(s) from the
history stored for that bit and then votes across these to get the resulting
classification(s).</p>
<p>The caller can choose to tell the region that the classifications for
iteration N+K should be aligned with the activationPattern for iteration N.
This results in the classifier producing predictions for K steps in advance.
Any number of different K&#8217;s can be specified, allowing the classifier to learn
and infer multi-step predictions for a number of steps in advance.</p>
<dl class="method">
<dt id="nupic.regions.CLAClassifierRegion.CLAClassifierRegion.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em>inputs</em>, <em>outputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.CLAClassifierRegion.CLAClassifierRegion.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process one input sample.
This method is called by the runtime engine.
&#64;param inputs &#8211; inputs of the classifier region
&#64;param outputs &#8211; outputs of the classifier region</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.CLAClassifierRegion.CLAClassifierRegion.customCompute">
<code class="descname">customCompute</code><span class="sig-paren">(</span><em>recordNum</em>, <em>patternNZ</em>, <em>classification</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.CLAClassifierRegion.CLAClassifierRegion.customCompute" title="Permalink to this definition">¶</a></dt>
<dd><p>Just return the inference value from one input sample. The actual 
learning happens in compute() &#8211; if, and only if learning is enabled &#8211; 
which is called when you run the network.</p>
<p>WARNING: The method customCompute() is here to maintain backward 
compatibility. This method is deprecated, and will be removed.
Use network.run() instead, which will call the compute() method.</p>
<p>recordNum:      Record number of the input sample.
patternNZ:      List of the active indices from the output below
classification: Dict of the classification information:</p>
<blockquote>
<div>bucketIdx: index of the encoder bucket
actValue:  actual value going into the encoder</div></blockquote>
<dl class="docutils">
<dt>retval:     dict containing inference results, one entry for each step in</dt>
<dd><p class="first">self.steps. The key is the number of steps, the value is an
array containing the relative likelihood for each bucketIdx
starting from bucketIdx 0.</p>
<dl class="last docutils">
<dt>for example:</dt>
<dd><dl class="first last docutils">
<dt>{&#8216;actualValues&#8217;: [0.0, 1.0, 2.0, 3.0]</dt>
<dd>1 : [0.1, 0.3, 0.2, 0.7]
4 : [0.2, 0.4, 0.3, 0.5]}</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.CLAClassifierRegion.CLAClassifierRegion.getAlgorithmInstance">
<code class="descname">getAlgorithmInstance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.CLAClassifierRegion.CLAClassifierRegion.getAlgorithmInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns instance of the underlying CLAClassifier algorithm object.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.CLAClassifierRegion.CLAClassifierRegion.getOutputElementCount">
<code class="descname">getOutputElementCount</code><span class="sig-paren">(</span><em>outputName</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.CLAClassifierRegion.CLAClassifierRegion.getOutputElementCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the width of dataOut.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.CLAClassifierRegion.CLAClassifierRegion.getOutputValues">
<code class="descname">getOutputValues</code><span class="sig-paren">(</span><em>outputName</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.CLAClassifierRegion.CLAClassifierRegion.getOutputValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dictionary of output values. Note that these are normal Python
lists, rather than numpy arrays. This is to support lists with mixed scalars
and strings, as in the case of records with categorical variables</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.CLAClassifierRegion.CLAClassifierRegion.getParameter">
<code class="descname">getParameter</code><span class="sig-paren">(</span><em>name</em>, <em>index=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.CLAClassifierRegion.CLAClassifierRegion.getParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of the parameter.</p>
<dl class="docutils">
<dt>&#64;param name &#8211; the name of the parameter to retrieve, as defined</dt>
<dd>by the Node Spec.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="nupic.regions.CLAClassifierRegion.CLAClassifierRegion.getProtoType">
<em class="property">static </em><code class="descname">getProtoType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.CLAClassifierRegion.CLAClassifierRegion.getProtoType" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pycapnp proto type that the class uses for serialization.</p>
</dd></dl>

<dl class="classmethod">
<dt id="nupic.regions.CLAClassifierRegion.CLAClassifierRegion.readFromProto">
<em class="property">classmethod </em><code class="descname">readFromProto</code><span class="sig-paren">(</span><em>proto</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.CLAClassifierRegion.CLAClassifierRegion.readFromProto" title="Permalink to this definition">¶</a></dt>
<dd><p>Read state from proto object.</p>
<p>proto: CLAClassifierRegionProto capnproto object</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.CLAClassifierRegion.CLAClassifierRegion.setParameter">
<code class="descname">setParameter</code><span class="sig-paren">(</span><em>name</em>, <em>index</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.CLAClassifierRegion.CLAClassifierRegion.setParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the parameter.</p>
<dl class="docutils">
<dt>&#64;param name &#8211; the name of the parameter to update, as defined</dt>
<dd>by the Node Spec.</dd>
</dl>
<p>&#64;param value &#8211; the value to which the parameter is to be set.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.CLAClassifierRegion.CLAClassifierRegion.writeToProto">
<code class="descname">writeToProto</code><span class="sig-paren">(</span><em>proto</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.CLAClassifierRegion.CLAClassifierRegion.writeToProto" title="Permalink to this definition">¶</a></dt>
<dd><p>Write state to proto object.</p>
<p>proto: CLAClassifierRegionProto capnproto object</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="knnanomalyclassifierregion">
<h2>KNNAnomalyClassifierRegion<a class="headerlink" href="#knnanomalyclassifierregion" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion">
<em class="property">class </em><code class="descclassname">nupic.regions.KNNAnomalyClassifierRegion.</code><code class="descname">KNNAnomalyClassifierRegion</code><span class="sig-paren">(</span><em>trainRecords</em>, <em>anomalyThreshold</em>, <em>cacheSize</em>, <em>classificationVectorType=1</em>, <em>activeColumnCount=40</em>, <em>classificationMaxDist=0.3</em>, <em>**classifierArgs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.bindings.regions.PyRegion.PyRegion" title="nupic.bindings.regions.PyRegion.PyRegion"><code class="xref py py-class docutils literal"><span class="pre">nupic.bindings.regions.PyRegion.PyRegion</span></code></a></p>
<p>KNNAnomalyClassifierRegion wraps the KNNClassifierRegion to classify clamodel
state.  It allows for individual records to be classified as anomalies and
supports anomaly detection even after the model has learned the anomalous
sequence.</p>
<dl class="docutils">
<dt>Methods:</dt>
<dd>compute() - called by clamodel during record processing
getLabels() - return points with classification records
addLabel() - add a set label to a given set of points
removeLabels() - remove labels from a given set of points</dd>
<dt>Parameters:</dt>
<dd><p class="first">trainRecords - number of records to skip before classification
anomalyThreshold - threshold on anomaly score to automatically classify</p>
<blockquote>
<div>record as an anomaly</div></blockquote>
<dl class="last docutils">
<dt>cacheSize - number of records to keep in cache. Can only recalculate</dt>
<dd>records kept in cache when setting the trainRecords.</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.addLabel">
<code class="descname">addLabel</code><span class="sig-paren">(</span><em>start</em>, <em>end</em>, <em>labelName</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.addLabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the label labelName to each record with record ROWID in range from
start to end, noninclusive of end.</p>
<p>This will recalculate all points from end to the last record stored in the
internal cache of this classifier.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.classifyState">
<code class="descname">classifyState</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.classifyState" title="Permalink to this definition">¶</a></dt>
<dd><p>Reclassifies given state.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.classifyStates">
<code class="descname">classifyStates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.classifyStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Reclassifies all internal state</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em>inputs</em>, <em>outputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process one input sample.
This method is called by the runtime engine.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.constructClassificationRecord">
<code class="descname">constructClassificationRecord</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.constructClassificationRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a _CLAClassificationRecord based on the state of the model
passed in through the inputs.</p>
<dl class="docutils">
<dt>Types for self.classificationVectorType:</dt>
<dd>1 - TP active cells in learn state
2 - SP columns concatenated with error from TP column predictions and SP</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.getLabelResults">
<code class="descname">getLabelResults</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.getLabelResults" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels of the previously computed record.</p>
<p>retval - array of strings representing the classification labels</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.getLabels">
<code class="descname">getLabels</code><span class="sig-paren">(</span><em>start=None</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.getLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the labels on classified points within range start to end. Not inclusive
of end.</p>
<p>reval - dict of format:</p>
<blockquote>
<div><dl class="docutils">
<dt>{</dt>
<dd>&#8216;isProcessing&#8217;: boolean,
&#8216;recordLabels&#8217;: list of results</dd>
</dl>
<p>}</p>
<dl class="docutils">
<dt>isProcessing - currently always false as recalculation blocks; used if</dt>
<dd>reprocessing of records is still being performed;</dd>
</dl>
<p>Each item in recordLabels is of format:
{</p>
<blockquote>
<div>&#8216;ROWID&#8217;: id of the row,
&#8216;labels&#8217;: list of strings</div></blockquote>
<p>}</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.getParameter">
<code class="descname">getParameter</code><span class="sig-paren">(</span><em>name</em>, <em>index=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.getParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of the parameter.</p>
<dl class="docutils">
<dt>&#64;param name &#8211; the name of the parameter to retrieve, as defined</dt>
<dd>by the Node Spec.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.removeLabels">
<code class="descname">removeLabels</code><span class="sig-paren">(</span><em>start=None</em>, <em>end=None</em>, <em>labelFilter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.removeLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove labels from each record with record ROWID in range from
start to end, noninclusive of end. Removes all records if labelFilter is
None, otherwise only removes the labels eqaul to labelFilter.</p>
<p>This will recalculate all points from end to the last record stored in the
internal cache of this classifier.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.setParameter">
<code class="descname">setParameter</code><span class="sig-paren">(</span><em>name</em>, <em>index</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNAnomalyClassifierRegion.KNNAnomalyClassifierRegion.setParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the parameter.</p>
<dl class="docutils">
<dt>&#64;param name &#8211; the name of the parameter to update, as defined</dt>
<dd>by the Node Spec.</dd>
</dl>
<p>&#64;param value &#8211; the value to which the parameter is to be set.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="knnclassifierregion">
<h2>KNNClassifierRegion<a class="headerlink" href="#knnclassifierregion" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion">
<em class="property">class </em><code class="descclassname">nupic.regions.KNNClassifierRegion.</code><code class="descname">KNNClassifierRegion</code><span class="sig-paren">(</span><em>maxCategoryCount=0</em>, <em>bestPrototypeIndexCount=0</em>, <em>outputProbabilitiesByDist=False</em>, <em>k=1</em>, <em>distanceNorm=2.0</em>, <em>distanceMethod='norm'</em>, <em>distThreshold=0.0</em>, <em>doBinarization=False</em>, <em>inputThresh=0.5</em>, <em>useSparseMemory=True</em>, <em>sparseThreshold=0.0</em>, <em>relativeThreshold=False</em>, <em>winnerCount=0</em>, <em>acceptanceProbability=1.0</em>, <em>seed=42</em>, <em>doSphering=False</em>, <em>SVDSampleCount=0</em>, <em>SVDDimCount=0</em>, <em>fractionOfMax=0</em>, <em>useAuxiliary=0</em>, <em>justUseAuxiliary=0</em>, <em>verbosity=0</em>, <em>replaceDuplicates=False</em>, <em>cellsPerCol=0</em>, <em>maxStoredPatterns=-1</em>, <em>minSparsity=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.bindings.regions.PyRegion.PyRegion" title="nupic.bindings.regions.PyRegion.PyRegion"><code class="xref py py-class docutils literal"><span class="pre">nupic.bindings.regions.PyRegion.PyRegion</span></code></a></p>
<p>KNNClassifierRegion implements the k Nearest Neighbor classification algorithm.
By default it will implement vanilla 1-nearest neighbor using the L2 (Euclidean)
distance norm.  There are options for using different norms as well as
various ways of sparsifying the input.</p>
<p>Note: categories are ints &gt;= 0.</p>
<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em>inputs</em>, <em>outputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process one input sample. This method is called by the runtime engine.</p>
<p>NOTE: the number of input categories may vary, but the array size is fixed
to the max number of categories allowed (by a lower region), so &#8220;unused&#8221;
indices of the input category array are filled with -1s.</p>
<p>TODO: confusion matrix does not support multi-label classification</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.disableTap">
<code class="descname">disableTap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.disableTap" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable writing of output tap files.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.doInference">
<code class="descname">doInference</code><span class="sig-paren">(</span><em>activeInput</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.doInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicitly run inference on a vector that is passed in and return the
category id. Useful for debugging.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.enableTap">
<code class="descname">enableTap</code><span class="sig-paren">(</span><em>tapPath</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.enableTap" title="Permalink to this definition">¶</a></dt>
<dd><p>Begin writing output tap files.</p>
<p>&#64;param tapPath &#8211; base name of the output tap files to write.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getAlgorithmInstance">
<code class="descname">getAlgorithmInstance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getAlgorithmInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns instance of the underlying KNNClassifier algorithm object.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getAllDistances">
<code class="descname">getAllDistances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getAllDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all the prototype distances from all computes available.</p>
<p>Like getLatestDistances, but returns all the scores if more than one set is
available. getLatestDistances will always just return one set of scores.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getCategoryList">
<code class="descname">getCategoryList</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getCategoryList" title="Permalink to this definition">¶</a></dt>
<dd><p>Public API for returning the category list
This is a required API of the NearestNeighbor inspector.</p>
<p>It returns an array which has one entry per stored prototype. The value
of the entry is the category # of that stored prototype.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getLatestDistances">
<code class="descname">getLatestDistances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getLatestDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Public API for returning the full scores
(distance to each prototype) from the last
compute() inference call.
This is a required API of the NearestNeighbor inspector.</p>
<p>It returns an array which has one entry per stored prototype. The value
of the entry is distance of the most recenty inferred input from the
stored prototype.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getOutputElementCount">
<code class="descname">getOutputElementCount</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getOutputElementCount" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will be called only when the node is used in nuPIC 2</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getParameter">
<code class="descname">getParameter</code><span class="sig-paren">(</span><em>name</em>, <em>index=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.getParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of the parameter.</p>
<dl class="docutils">
<dt>&#64;param name &#8211; the name of the parameter to retrieve, as defined</dt>
<dd>by the Node Spec.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.handleLogInput">
<code class="descname">handleLogInput</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.handleLogInput" title="Permalink to this definition">¶</a></dt>
<dd><p>Write inputs to output tap file.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.handleLogOutput">
<code class="descname">handleLogOutput</code><span class="sig-paren">(</span><em>output</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.handleLogOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Write outputs to output tap file.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.KNNClassifierRegion.KNNClassifierRegion.setParameter">
<code class="descname">setParameter</code><span class="sig-paren">(</span><em>name</em>, <em>index</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.KNNClassifierRegion.KNNClassifierRegion.setParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the parameter.</p>
<dl class="docutils">
<dt>&#64;param name &#8211; the name of the parameter to update, as defined</dt>
<dd>by the Node Spec.</dd>
</dl>
<p>&#64;param value &#8211; the value to which the parameter is to be set.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sdrclassifierregion">
<h2>SDRClassifierRegion<a class="headerlink" href="#sdrclassifierregion" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.regions.SDRClassifierRegion.SDRClassifierRegion">
<em class="property">class </em><code class="descclassname">nupic.regions.SDRClassifierRegion.</code><code class="descname">SDRClassifierRegion</code><span class="sig-paren">(</span><em>steps='1'</em>, <em>alpha=0.001</em>, <em>verbosity=0</em>, <em>implementation=None</em>, <em>maxCategoryCount=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SDRClassifierRegion.SDRClassifierRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.bindings.regions.PyRegion.PyRegion" title="nupic.bindings.regions.PyRegion.PyRegion"><code class="xref py py-class docutils literal"><span class="pre">nupic.bindings.regions.PyRegion.PyRegion</span></code></a></p>
<p>SDRClassifierRegion implements a SDR classifier that accepts a binary
input from the level below (the &#8220;activationPattern&#8221;) and information from the
sensor and encoders (the &#8220;classification&#8221;) describing the input to the system
at that time step.</p>
<p>The SDR classifier maps input patterns to class labels. There are as many
output units as the number of class labels or buckets (in the case of scalar
encoders). The output is a probabilistic distribution over all class labels.</p>
<p>During inference, the output is calculated by first doing a weighted summation
of all the inputs, and then perform a softmax nonlinear function to get
the predicted distribution of class labels</p>
<p>During learning, the connection weights between input units and output units
are adjusted to maximize the likelihood of the model</p>
<p>The caller can choose to tell the region that the classifications for
iteration N+K should be aligned with the activationPattern for iteration N.
This results in the classifier producing predictions for K steps in advance.
Any number of different K&#8217;s can be specified, allowing the classifier to learn
and infer multi-step predictions for a number of steps in advance.</p>
<dl class="method">
<dt id="nupic.regions.SDRClassifierRegion.SDRClassifierRegion.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em>inputs</em>, <em>outputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SDRClassifierRegion.SDRClassifierRegion.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process one input sample.
This method is called by the runtime engine.
&#64;param inputs &#8211; inputs of the classifier region
&#64;param outputs &#8211; outputs of the classifier region</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.SDRClassifierRegion.SDRClassifierRegion.customCompute">
<code class="descname">customCompute</code><span class="sig-paren">(</span><em>recordNum</em>, <em>patternNZ</em>, <em>classification</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SDRClassifierRegion.SDRClassifierRegion.customCompute" title="Permalink to this definition">¶</a></dt>
<dd><p>Just return the inference value from one input sample. The actual 
learning happens in compute() &#8211; if, and only if learning is enabled &#8211; 
which is called when you run the network.</p>
<p>WARNING: The method customCompute() is here to maintain backward 
compatibility. This method is deprecated, and will be removed.
Use network.run() instead, which will call the compute() method.</p>
<p>recordNum:      Record number of the input sample.
patternNZ:      List of the active indices from the output below
classification: Dict of the classification information:</p>
<blockquote>
<div>bucketIdx: index of the encoder bucket
actValue:  actual value going into the encoder</div></blockquote>
<dl class="docutils">
<dt>retval:     dict containing inference results, one entry for each step in</dt>
<dd><p class="first">self.steps. The key is the number of steps, the value is an
array containing the relative likelihood for each bucketIdx
starting from bucketIdx 0.</p>
<dl class="last docutils">
<dt>for example:</dt>
<dd><dl class="first last docutils">
<dt>{&#8216;actualValues&#8217;: [0.0, 1.0, 2.0, 3.0]</dt>
<dd>1 : [0.1, 0.3, 0.2, 0.7]
4 : [0.2, 0.4, 0.3, 0.5]}</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.SDRClassifierRegion.SDRClassifierRegion.getAlgorithmInstance">
<code class="descname">getAlgorithmInstance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SDRClassifierRegion.SDRClassifierRegion.getAlgorithmInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns instance of the underlying SDRClassifier algorithm object.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.SDRClassifierRegion.SDRClassifierRegion.getOutputElementCount">
<code class="descname">getOutputElementCount</code><span class="sig-paren">(</span><em>outputName</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SDRClassifierRegion.SDRClassifierRegion.getOutputElementCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of output elements.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.SDRClassifierRegion.SDRClassifierRegion.getParameter">
<code class="descname">getParameter</code><span class="sig-paren">(</span><em>name</em>, <em>index=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SDRClassifierRegion.SDRClassifierRegion.getParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of the parameter.</p>
<dl class="docutils">
<dt>&#64;param name &#8211; the name of the parameter to retrieve, as defined</dt>
<dd>by the Node Spec.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="nupic.regions.SDRClassifierRegion.SDRClassifierRegion.getProtoType">
<em class="property">static </em><code class="descname">getProtoType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SDRClassifierRegion.SDRClassifierRegion.getProtoType" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pycapnp proto type that the class uses for serialization.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.SDRClassifierRegion.SDRClassifierRegion.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>inputs</em>, <em>outputs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SDRClassifierRegion.SDRClassifierRegion.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Is called once by NuPIC before the first call to compute().
Initializes self._sdrClassifier is it is not already initialized.
&#64;param inputs &#8211; inputs of the classifier region
&#64;param outputs &#8211; outputs of the classifier region</p>
</dd></dl>

<dl class="classmethod">
<dt id="nupic.regions.SDRClassifierRegion.SDRClassifierRegion.readFromProto">
<em class="property">classmethod </em><code class="descname">readFromProto</code><span class="sig-paren">(</span><em>proto</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SDRClassifierRegion.SDRClassifierRegion.readFromProto" title="Permalink to this definition">¶</a></dt>
<dd><p>Read state from proto object.</p>
<p>proto: SDRClassifierRegionProto capnproto object</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.SDRClassifierRegion.SDRClassifierRegion.setParameter">
<code class="descname">setParameter</code><span class="sig-paren">(</span><em>name</em>, <em>index</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SDRClassifierRegion.SDRClassifierRegion.setParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of the parameter.</p>
<dl class="docutils">
<dt>&#64;param name &#8211; the name of the parameter to update, as defined</dt>
<dd>by the Node Spec.</dd>
</dl>
<p>&#64;param value &#8211; the value to which the parameter is to be set.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.regions.SDRClassifierRegion.SDRClassifierRegion.writeToProto">
<code class="descname">writeToProto</code><span class="sig-paren">(</span><em>proto</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.regions.SDRClassifierRegion.SDRClassifierRegion.writeToProto" title="Permalink to this definition">¶</a></dt>
<dd><p>Write state to proto object.</p>
<p>proto: SDRClassifierRegionProto capnproto object</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/numenta-logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Regions</a><ul>
<li><a class="reference internal" href="#pyregion">PyRegion</a></li>
<li><a class="reference internal" href="#anomalyregion">AnomalyRegion</a></li>
<li><a class="reference internal" href="#spregion">SPRegion</a></li>
<li><a class="reference internal" href="#tpregion">TPRegion</a></li>
<li><a class="reference internal" href="#anomalylikelihoodregion">AnomalyLikelihoodRegion</a></li>
<li><a class="reference internal" href="#claclassifierregion">CLAClassifierRegion</a></li>
<li><a class="reference internal" href="#knnanomalyclassifierregion">KNNAnomalyClassifierRegion</a></li>
<li><a class="reference internal" href="#knnclassifierregion">KNNClassifierRegion</a></li>
<li><a class="reference internal" href="#sdrclassifierregion">SDRClassifierRegion</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="network.html">Network API</a><ul>
      <li>Previous: <a href="network-network.html" title="previous chapter">Network</a></li>
      <li>Next: <a href="network-sensors.html" title="next chapter">Sensors</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/network-regions.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Numenta.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/network-regions.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/numenta/nupic" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>