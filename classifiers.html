<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Classifiers &#8212; NuPIC 0.5.8.dev0
 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5.8.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Network API" href="network.html" />
    <link rel="prev" title="Temporal Memory" href="temporal-memory.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="classifiers">
<h1>Classifiers<a class="headerlink" href="#classifiers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="sdr-classifier">
<h2>SDR Classifier<a class="headerlink" href="#sdr-classifier" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.algorithms.sdr_classifier.SDRClassifier">
<em class="property">class </em><code class="descclassname">nupic.algorithms.sdr_classifier.</code><code class="descname">SDRClassifier</code><span class="sig-paren">(</span><em>steps=(1</em>, <em>)</em>, <em>alpha=0.001</em>, <em>actValueAlpha=0.3</em>, <em>verbosity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.sdr_classifier.SDRClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>The SDR Classifier accepts a binary input pattern from the
level below (the &#8220;activationPattern&#8221;) and information from the sensor and
encoders (the &#8220;classification&#8221;) describing the true (target) input.</p>
<p>The SDR classifier maps input patterns to class labels. There are as many
output units as the number of class labels or buckets (in the case of scalar
encoders). The output is a probabilistic distribution over all class labels.</p>
<p>During inference, the output is calculated by first doing a weighted summation
of all the inputs, and then perform a softmax nonlinear function to get
the predicted distribution of class labels</p>
<p>During learning, the connection weights between input units and output units
are adjusted to maximize the likelihood of the model</p>
<p>The SDR Classifier is a variation of the previous CLAClassifier which was
not based on the references below.</p>
<p>Example Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">SDRClassifier</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">actValueAlpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># learning</span>
<span class="n">c</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">recordNum</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">patternNZ</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
          <span class="n">classification</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;bucketIdx&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;actValue&quot;</span><span class="p">:</span> <span class="mf">34.7</span><span class="p">},</span>
          <span class="n">learn</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">infer</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># inference</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">recordNum</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">patternNZ</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
                   <span class="n">classification</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;bucketIdx&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;actValue&quot;</span><span class="p">:</span> <span class="mf">34.7</span><span class="p">},</span>
                   <span class="n">learn</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">infer</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Print the top three predictions for 1 steps out.</span>
<span class="n">topPredictions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;actualValues&quot;</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
<span class="k">for</span> <span class="n">probability</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">topPredictions</span><span class="p">:</span>
  <span class="k">print</span> <span class="s2">&quot;Prediction of {} has probability of {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span>
                                                         <span class="n">probability</span><span class="o">*</span><span class="mf">100.0</span><span class="p">)</span>
</pre></div>
</div>
<p>References:</p>
<ul class="simple">
<li>Alex Graves. Supervised Sequence Labeling with Recurrent Neural Networks,
PhD Thesis, 2008</li>
<li>J. S. Bridle. Probabilistic interpretation of feedforward classification
network outputs, with relationships to statistical pattern recognition</li>
<li>In F. Fogleman-Soulie and J.Herault, editors, Neurocomputing: Algorithms,
Architectures and Applications, pp 227-236, Springer-Verlag, 1990</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>steps</strong> &#8211; (list) Sequence of the different steps of multi-step predictions
to learn</li>
<li><strong>alpha</strong> &#8211; (float) The alpha used to adapt the weight matrix during
learning. A larger alpha results in faster adaptation to the data.</li>
<li><strong>actValueAlpha</strong> &#8211; (float) Used to track the actual value within each
bucket. A lower actValueAlpha results in longer term memory</li>
<li><strong>verbosity</strong> &#8211; (int) verbosity level, can be 0, 1, or 2</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nupic.algorithms.sdr_classifier.SDRClassifier.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em>recordNum</em>, <em>patternNZ</em>, <em>classification</em>, <em>learn</em>, <em>infer</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.sdr_classifier.SDRClassifier.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process one input sample.</p>
<p>This method is called by outer loop code outside the nupic-engine. We
use this instead of the nupic engine compute() because our inputs and
outputs aren&#8217;t fixed size vectors of reals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>recordNum</strong> &#8211; Record number of this input pattern. Record numbers
normally increase sequentially by 1 each time unless there are missing
records in the dataset. Knowing this information insures that we don&#8217;t get
confused by missing records.</li>
<li><strong>patternNZ</strong> &#8211; List of the active indices from the output below. When the
input is from TemporalMemory, this list should be the indices of the
active cells.</li>
<li><strong>classification</strong> &#8211; <p>Dict of the classification information where:</p>
<ul>
<li>bucketIdx: index of the encoder bucket</li>
<li>actValue: actual value going into the encoder</li>
</ul>
<p>Classification could be None for inference mode.</p>
</li>
<li><strong>learn</strong> &#8211; (bool) if true, learn this sample</li>
<li><strong>infer</strong> &#8211; (bool) if true, perform inference</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>Dict containing inference results, there is one entry for each
step in self.steps, where the key is the number of steps, and
the value is an array containing the relative likelihood for
each bucketIdx starting from bucketIdx 0.</p>
<p>There is also an entry containing the average actual value to
use for each bucket. The key is &#8216;actualValues&#8217;.</p>
<p>for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span><span class="mi">1</span> <span class="p">:</span>             <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span>
  <span class="mi">4</span> <span class="p">:</span>             <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
  <span class="s1">&#39;actualValues&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="mf">7.6</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.sdr_classifier.SDRClassifier.infer">
<code class="descname">infer</code><span class="sig-paren">(</span><em>patternNZ</em>, <em>classification</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.sdr_classifier.SDRClassifier.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inference value from one input sample. The actual
learning happens in compute().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>patternNZ</strong> &#8211; list of the active indices from the output below</li>
<li><strong>classification</strong> &#8211; dict of the classification information:
bucketIdx: index of the encoder bucket
actValue:  actual value going into the encoder</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>dict containing inference results, one entry for each step in
self.steps. The key is the number of steps, the value is an
array containing the relative likelihood for each bucketIdx
starting from bucketIdx 0.</p>
<p>for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;actualValues&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>
  <span class="mi">1</span> <span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]</span>
  <span class="mi">4</span> <span class="p">:</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]}</span>
</pre></div>
</div>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.sdr_classifier.SDRClassifier.inferSingleStep">
<code class="descname">inferSingleStep</code><span class="sig-paren">(</span><em>patternNZ</em>, <em>weightMatrix</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.sdr_classifier.SDRClassifier.inferSingleStep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform inference for a single step. Given an SDR input and a weight
matrix, return a predicted distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>patternNZ</strong> &#8211; list of the active indices from the output below</li>
<li><strong>weightMatrix</strong> &#8211; numpy array of the weight matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array of the predicted class label distribution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="cla-classifier">
<h2>CLA Classifier<a class="headerlink" href="#cla-classifier" title="Permalink to this headline">¶</a></h2>
<p>Outdated. Use SDR Classifier.</p>
<dl class="class">
<dt id="nupic.algorithms.CLAClassifier.CLAClassifier">
<em class="property">class </em><code class="descclassname">nupic.algorithms.CLAClassifier.</code><code class="descname">CLAClassifier</code><span class="sig-paren">(</span><em>steps=(1</em>, <em>)</em>, <em>alpha=0.001</em>, <em>actValueAlpha=0.3</em>, <em>verbosity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.CLAClassifier.CLAClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>A CLA classifier accepts a binary input from the level below (the
&#8220;activationPattern&#8221;) and information from the sensor and encoders (the
&#8220;classification&#8221;) describing the input to the system at that time step.</p>
<p>When learning, for every bit in activation pattern, it records a history of 
the classification each time that bit was active. The history is weighted so 
that more recent activity has a bigger impact than older activity. The alpha
parameter controls this weighting.</p>
<p>For inference, it takes an ensemble approach. For every active bit in the
activationPattern, it looks up the most likely classification(s) from the
history stored for that bit and then votes across these to get the resulting
classification(s).</p>
<p>This classifier can learn and infer a number of simultaneous classifications
at once, each representing a shift of a different number of time steps. For
example, say you are doing multi-step prediction and want the predictions for
1 and 3 time steps in advance. The CLAClassifier would learn the associations
between the activation pattern for time step T and the classifications for
time step T+1, as well as the associations between activation pattern T and
the classifications for T+3. The &#8216;steps&#8217; constructor argument specifies the
list of time-steps you want.</p>
<dl class="method">
<dt id="nupic.algorithms.CLAClassifier.CLAClassifier.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em>recordNum</em>, <em>patternNZ</em>, <em>classification</em>, <em>learn</em>, <em>infer</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.CLAClassifier.CLAClassifier.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process one input sample.
This method is called by outer loop code outside the nupic-engine. We
use this instead of the nupic engine compute() because our inputs and
outputs aren&#8217;t fixed size vectors of reals.</p>
<dl class="docutils">
<dt>recordNum:  Record number of this input pattern. Record numbers should</dt>
<dd>normally increase sequentially by 1 each time unless there
are missing records in the dataset. Knowing this information
insures that we don&#8217;t get confused by missing records.</dd>
<dt>patternNZ:  List of the active indices from the output below.</dt>
<dd><ul class="first last simple">
<li>When the input is from TemporalMemory, this list should be the
indices of the active cells.</li>
</ul>
</dd>
<dt>classification: dict of the classification information:</dt>
<dd>bucketIdx: index of the encoder bucket
actValue:  actual value going into the encoder</dd>
</dl>
<p>learn:      if true, learn this sample
infer:      if true, perform inference</p>
<dl class="docutils">
<dt>retval:     dict containing inference results, there is one entry for each</dt>
<dd><p class="first">step in self.steps, where the key is the number of steps, and
the value is an array containing the relative likelihood for
each bucketIdx starting from bucketIdx 0.</p>
<p>There is also an entry containing the average actual value to
use for each bucket. The key is &#8216;actualValues&#8217;.</p>
<dl class="last docutils">
<dt>for example:</dt>
<dd><dl class="first docutils">
<dt>{1 <span class="classifier-delimiter">:</span> <span class="classifier">[0.1, 0.3, 0.2, 0.7],</span></dt>
<dd>4 :             [0.2, 0.4, 0.3, 0.5],
&#8216;actualValues&#8217;: [1.5, 3,5, 5,5, 7.6],</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.CLAClassifier.CLAClassifier.infer">
<code class="descname">infer</code><span class="sig-paren">(</span><em>patternNZ</em>, <em>classification</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.CLAClassifier.CLAClassifier.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inference value from one input sample. The actual 
learning happens in compute(). The method customCompute() is here to 
maintain backward compatibility.</p>
<p>patternNZ:      list of the active indices from the output below
classification: dict of the classification information:</p>
<blockquote>
<div>bucketIdx: index of the encoder bucket
actValue:  actual value going into the encoder</div></blockquote>
<dl class="docutils">
<dt>retval:     dict containing inference results, one entry for each step in</dt>
<dd><p class="first">self.steps. The key is the number of steps, the value is an
array containing the relative likelihood for each bucketIdx
starting from bucketIdx 0.</p>
<dl class="last docutils">
<dt>for example:</dt>
<dd><dl class="first last docutils">
<dt>{&#8216;actualValues&#8217;: [0.0, 1.0, 2.0, 3.0]</dt>
<dd>1 : [0.1, 0.3, 0.2, 0.7]
4 : [0.2, 0.4, 0.3, 0.5]}</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/numenta-logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Classifiers</a><ul>
<li><a class="reference internal" href="#sdr-classifier">SDR Classifier</a></li>
<li><a class="reference internal" href="#cla-classifier">CLA Classifier</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="algorithms.html">Algorithms</a><ul>
      <li>Previous: <a href="temporal-memory.html" title="previous chapter">Temporal Memory</a></li>
      <li>Next: <a href="network.html" title="next chapter">Network API</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/classifiers.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Numenta.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/classifiers.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/numenta/nupic" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>