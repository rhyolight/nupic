<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Encoders &#8212; NuPIC 0.5.8.dev0
 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5.8.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Algorithms" href="algorithms.html" />
    <link rel="prev" title="Hot Gym Code Example" href="guide-sample-code.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="encoders">
<h1>Encoders<a class="headerlink" href="#encoders" title="Permalink to this headline">¶</a></h1>
<div class="section" id="encoder">
<h2>Encoder<a class="headerlink" href="#encoder" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.encoders.base.Encoder">
<em class="property">class </em><code class="descclassname">nupic.encoders.base.</code><code class="descname">Encoder</code><a class="headerlink" href="#nupic.encoders.base.Encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>An encoder converts a value to a sparse distributed representation.</p>
<p>This is the base class for encoders that are compatible with the OPF. The OPF
requires that values can be represented as a scalar value for use in places
like the SDR Classifier.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The Encoder superclass implements:</p>
</div>
<ul class="simple">
<li><a class="reference internal" href="#nupic.encoders.base.Encoder.encode" title="nupic.encoders.base.Encoder.encode"><code class="xref py py-func docutils literal"><span class="pre">encode()</span></code></a> - returns a numpy array encoding
the input; syntactic sugar on top of encodeIntoArray. If pprint, prints the
encoding to the terminal</li>
<li><a class="reference internal" href="#nupic.encoders.base.Encoder.pprintHeader" title="nupic.encoders.base.Encoder.pprintHeader"><code class="xref py py-func docutils literal"><span class="pre">pprintHeader()</span></code></a> - prints a header
describing the encoding to the terminal</li>
<li><a class="reference internal" href="#nupic.encoders.base.Encoder.pprint" title="nupic.encoders.base.Encoder.pprint"><code class="xref py py-func docutils literal"><span class="pre">pprint()</span></code></a> - prints an encoding to the
terminal</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The following methods and properties must be implemented by
subclasses:</p>
</div>
<ul>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#nupic.encoders.base.Encoder.getDecoderOutputFieldTypes" title="nupic.encoders.base.Encoder.getDecoderOutputFieldTypes"><code class="xref py py-func docutils literal"><span class="pre">getDecoderOutputFieldTypes()</span></code></a> - must be</dt>
<dd><p class="first last">implemented by leaf encoders. Returns <a class="reference internal" href="#nupic.data.fieldmeta.FieldMetaType" title="nupic.data.fieldmeta.FieldMetaType"><code class="xref py py-class docutils literal"><span class="pre">nupic.data.fieldmeta.FieldMetaType</span></code></a>.XXXXX
(e.g., <a class="reference internal" href="#nupic.data.fieldmeta.FieldMetaType" title="nupic.data.fieldmeta.FieldMetaType"><code class="xref py py-class docutils literal"><span class="pre">nupic.data.fieldmeta.FieldMetaType</span></code></a>.float)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#nupic.encoders.base.Encoder.getWidth" title="nupic.encoders.base.Encoder.getWidth"><code class="xref py py-func docutils literal"><span class="pre">getWidth()</span></code></a> - returns the output width, in</dt>
<dd><p class="first last">bits</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#nupic.encoders.base.Encoder.encodeIntoArray" title="nupic.encoders.base.Encoder.encodeIntoArray"><code class="xref py py-func docutils literal"><span class="pre">encodeIntoArray()</span></code></a> - encodes input and</dt>
<dd><p class="first last">puts the encoded value into the numpy output array, which is a 1-D array of
length returned by <a class="reference internal" href="#nupic.encoders.base.Encoder.getWidth" title="nupic.encoders.base.Encoder.getWidth"><code class="xref py py-func docutils literal"><span class="pre">getWidth()</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#nupic.encoders.base.Encoder.getDescription" title="nupic.encoders.base.Encoder.getDescription"><code class="xref py py-func docutils literal"><span class="pre">getDescription()</span></code></a> - returns a list of</dt>
<dd><p class="first last">(name, offset) pairs describing the encoded output</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="nupic.encoders.base.Encoder.closenessScores">
<code class="descname">closenessScores</code><span class="sig-paren">(</span><em>expValues</em>, <em>actValues</em>, <em>fractional=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.closenessScores" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute closeness scores between the expected scalar value(s) and actual
scalar value(s). The expected scalar values are typically those obtained
from the getScalars() method. The actual scalar values are typically those
returned from the topDownCompute() method.</p>
<p>This method returns one closeness score for each value in expValues (or
actValues which must be the same length). The closeness score ranges from
0 to 1.0, 1.0 being a perfect match and 0 being the worst possible match.</p>
<p>If this encoder is a simple, single field encoder, then it will expect
just 1 item in each of the expValues and actValues arrays. Multi-encoders
will expect 1 item per sub-encoder.</p>
<p>Each encoder type can define it&#8217;s own metric for closeness. For example,
a category encoder may return either 1 or 0, if the scalar matches exactly
or not. A scalar encoder might return a percentage match, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>expValues</strong> &#8211; Array of expected scalar values, typically obtained from
getScalars()</li>
<li><strong>actValues</strong> &#8211; Array of actual values, typically obtained from
topDownCompute()</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Array of closeness scores, one per item in expValues (or
actValues).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>encoded</em>, <em>parentFieldName=''</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an encoded output and does its best to work backwards and generate
the input that would have generated it.</p>
<p>In cases where the encoded output contains more ON bits than an input
would have generated, this routine will return one or more ranges of inputs
which, if their encoded outputs were ORed together, would produce the
target output. This behavior makes this method suitable for doing things
like generating a description of a learned coincidence in the SP, which
in many cases might be a union of one or more inputs.</p>
<p>If instead, you want to figure the <em>most likely</em> single input scalar value
that would have generated a specific encoded output, use the topDownCompute()
method.</p>
<p>If you want to pretty print the return value from this method, use the
decodedToStr() method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>encoded</strong> &#8211; The encoded output that you want decode</li>
<li><strong>parentFieldName</strong> &#8211; The name of the encoder which is our parent. This name
is prefixed to each of the field names within this encoder to form the
keys of the dict() in the retval.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">tuple(fieldsDict, fieldOrder) (see below for details)</p>
</td>
</tr>
</tbody>
</table>
<p>fieldsDict is a dict() where the keys represent field names
(only 1 if this is a simple encoder, &gt; 1 if this is a multi
or date encoder) and the values are the result of decoding each
field. If there are  no bits in encoded that would have been
generated by a field, it won&#8217;t be present in the dict. The
key of each entry in the dict is formed by joining the passed in
parentFieldName with the child encoder name using a &#8216;.&#8217;.</p>
<p>Each &#8216;value&#8217; in fieldsDict consists of (ranges, desc), where
ranges is a list of one or more (minVal, maxVal) ranges of
input that would generate bits in the encoded output and &#8216;desc&#8217;
is a pretty print description of the ranges. For encoders like
the category encoder, the &#8216;desc&#8217; will contain the category
names that correspond to the scalar values included in the
ranges.</p>
<p>The fieldOrder is a list of the keys from fieldsDict, in the
same order as the fields appear in the encoded output.</p>
<p>TODO: when we switch to Python 2.7 or 3.x, use OrderedDict</p>
<p>Example retvals for a scalar encoder:</p>
<blockquote>
<div>{&#8216;amount&#8217;:  ( [[1,3], [7,10]], &#8216;1-3, 7-10&#8217; )}
{&#8216;amount&#8217;:  ( [[2.5,2.5]],     &#8216;2.5&#8217;       )}</div></blockquote>
<p>Example retval for a category encoder:</p>
<blockquote>
<div>{&#8216;country&#8217;: ( [[1,1], [5,6]], &#8216;US, GB, ES&#8217; )}</div></blockquote>
<p>Example retval for a multi encoder:</p>
<blockquote>
<div><dl class="docutils">
<dt>{&#8216;amount&#8217;:  ( [[2.5,2.5]],     &#8216;2.5&#8217;       ),</dt>
<dd>&#8216;country&#8217;: ( [[1,1], [5,6]],  &#8216;US, GB, ES&#8217; )}</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.decodedToStr">
<code class="descname">decodedToStr</code><span class="sig-paren">(</span><em>decodeResults</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.decodedToStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pretty print string representing the return value from decode().</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.encode">
<code class="descname">encode</code><span class="sig-paren">(</span><em>inputData</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience wrapper for encodeIntoArray.</p>
<p>This may be less efficient because it allocates a new numpy array every
call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>inputData</strong> &#8211; undocumented</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a numpy array with the encoded representation of inputData</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.encodeIntoArray">
<code class="descname">encodeIntoArray</code><span class="sig-paren">(</span><em>inputData</em>, <em>output</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.encodeIntoArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes inputData and puts the encoded value into the numpy output array,
which is a 1-D array of length returned by getWidth().</p>
<p>Note: The numpy output array is reused, so clear it before updating it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inputData</strong> &#8211; Data to encode. This should be validated by the encoder.</li>
<li><strong>output</strong> &#8211; numpy 1-D array of same length returned by getWidth()</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.encodedBitDescription">
<code class="descname">encodedBitDescription</code><span class="sig-paren">(</span><em>bitOffset</em>, <em>formatted=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.encodedBitDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a description of the given bit in the encoded output.
This will include the field name and the offset within the field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bitOffset</strong> &#8211; Offset of the bit to get the description of</li>
<li><strong>formatted</strong> &#8211; If True, the bitOffset is w.r.t. formatted output,
which includes separators</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">tuple(fieldName, offsetWithinField)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.formatBits">
<code class="descname">formatBits</code><span class="sig-paren">(</span><em>inarray</em>, <em>outarray</em>, <em>scale=1</em>, <em>blank=255</em>, <em>leftpad=0</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.formatBits" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy one array to another, inserting blanks
between fields (for display)
If leftpad is one, then there is a dummy value at element 0
of the arrays, and we should start our counting from 1 rather than 0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inarray</strong> &#8211; TODO: document</li>
<li><strong>outarray</strong> &#8211; TODO: document</li>
<li><strong>scale</strong> &#8211; TODO: document</li>
<li><strong>blank</strong> &#8211; TODO: document</li>
<li><strong>leftpad</strong> &#8211; TODO: document</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getBucketIndices">
<code class="descname">getBucketIndices</code><span class="sig-paren">(</span><em>inputData</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getBucketIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array containing the sub-field bucket indices for
each sub-field of the inputData. To get the associated field names for each of
the buckets, call getScalarNames().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>inputData</strong> &#8211; The data from the source. This is typically a object with
members.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array of bucket indices</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getBucketInfo">
<code class="descname">getBucketInfo</code><span class="sig-paren">(</span><em>buckets</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getBucketInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of EncoderResult namedtuples describing the inputs for
each sub-field that correspond to the bucket indices passed in &#8216;buckets&#8217;.
To get the associated field names for each of the values, call getScalarNames().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>buckets</strong> &#8211; The list of bucket indices, one for each sub-field encoder.
These bucket indices for example may have been retrieved
from the getBucketIndices() call.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of EncoderResult namedtuples. Each EncoderResult has
three attributes:<dl class="docutils">
<dt>-# value:         This is the value for the sub-field</dt>
<dd>in a format that is consistent with the type
specified by getDecoderOutputFieldTypes().
Note that this value is not necessarily
numeric.</dd>
<dt>-# scalar:        The scalar representation of value. This</dt>
<dd>number is consistent with what is returned
by getScalars(). This value is always an
int or float, and can be used for
numeric comparisons</dd>
<dt>-# encoding       This is the encoded bit-array (numpy array)</dt>
<dd>that represents &#8216;value&#8217;. That is, if &#8216;value&#8217;
was passed to encode(), an identical
bit-array should be returned</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getBucketValues">
<code class="descname">getBucketValues</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getBucketValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of items, one for each bucket defined by this encoder.
Each item is the value assigned to that bucket, this is the same as the
EncoderResult.value that would be returned by getBucketInfo() for that
bucket and is in the same format as the input that would be passed to
encode().</p>
<p>This call is faster than calling getBucketInfo() on each bucket individually
if all you need are the bucket values.</p>
<p><strong>Must be overridden by subclasses.</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of items, each item representing the bucket value for that
bucket.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getDecoderOutputFieldTypes">
<code class="descname">getDecoderOutputFieldTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getDecoderOutputFieldTypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sequence of field types corresponding to the elements in the
decoded output field array.  The types are defined by
<a class="reference internal" href="#nupic.data.fieldmeta.FieldMetaType" title="nupic.data.fieldmeta.FieldMetaType"><code class="xref py py-class docutils literal"><span class="pre">nupic.data.fieldmeta.FieldMetaType</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of <a class="reference internal" href="#nupic.data.fieldmeta.FieldMetaType" title="nupic.data.fieldmeta.FieldMetaType"><code class="xref py py-class docutils literal"><span class="pre">nupic.data.fieldmeta.FieldMetaType</span></code></a> objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getDescription">
<code class="descname">getDescription</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>This returns a list of tuples, each containing (name, offset).
The &#8216;name&#8217; is a string description of each sub-field, and offset is the bit
offset of the sub-field for that encoder.</p>
<p>For now, only the &#8216;multi&#8217; and &#8216;date&#8217; encoders have multiple (name, offset)
pairs. All other encoders have a single pair, where the offset is 0.</p>
<p><strong>Must be overridden by subclasses.</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of tuples containing (name, offset)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getDisplayWidth">
<code class="descname">getDisplayWidth</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getDisplayWidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate width of display for bits plus blanks between fields.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">width of display for bits plus blanks between fields</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getEncodedValues">
<code class="descname">getEncodedValues</code><span class="sig-paren">(</span><em>inputData</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getEncodedValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the input in the same format as is returned by topDownCompute().
For most encoder types, this is the same as the input data.
For instance, for scalar and category types, this corresponds to the numeric
and string values, respectively, from the inputs. For datetime encoders, this
returns the list of scalars for each of the sub-fields (timeOfDay, dayOfWeek, etc.)</p>
<p>This method is essentially the same as getScalars() except that it returns
strings</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>inputData</strong> &#8211; The input data in the format it is received from the data source</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of values, in the same format and in the same order as they</td>
</tr>
</tbody>
</table>
<p>are returned by topDownCompute.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getEncoderList">
<code class="descname">getEncoderList</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getEncoderList" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a reference to each sub-encoder in this encoder. They are
returned in the same order as they are for getScalarNames() and
getScalars().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getFieldDescription">
<code class="descname">getFieldDescription</code><span class="sig-paren">(</span><em>fieldName</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getFieldDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the offset and length of a given field within the encoded output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fieldName</strong> &#8211; Name of the field</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">tuple(offset, width) of the field within the encoded output</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getScalarNames">
<code class="descname">getScalarNames</code><span class="sig-paren">(</span><em>parentFieldName=''</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getScalarNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the field names for each of the scalar values returned by
getScalars.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parentFieldName</strong> &#8211; The name of the encoder which is our parent. This
name is prefixed to each of the field names within this encoder to
form the keys of the dict() in the retval.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array of field names</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getScalars">
<code class="descname">getScalars</code><span class="sig-paren">(</span><em>inputData</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getScalars" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a numpy array containing the sub-field scalar value(s) for
each sub-field of the inputData. To get the associated field names for each of
the scalar values, call getScalarNames().</p>
<p>For a simple scalar encoder, the scalar value is simply the input unmodified.
For category encoders, it is the scalar representing the category string
that is passed in. For the datetime encoder, the scalar value is the
the number of seconds since epoch.</p>
<p>The intent of the scalar representation of a sub-field is to provide a
baseline for measuring error differences. You can compare the scalar value
of the inputData with the scalar value returned from topDownCompute() on a
top-down representation to evaluate prediction accuracy, for example.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>inputData</strong> &#8211; The data from the source. This is typically a object with
members</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array of scalar values</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.getWidth">
<code class="descname">getWidth</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.getWidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Should return the output width, in bits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">output width in bits</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.pprint">
<code class="descname">pprint</code><span class="sig-paren">(</span><em>output</em>, <em>prefix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.pprint" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty-print the encoded output using ascii art.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>output</strong> &#8211; to print</li>
<li><strong>prefix</strong> &#8211; printed before the header if specified</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.pprintHeader">
<code class="descname">pprintHeader</code><span class="sig-paren">(</span><em>prefix=''</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.pprintHeader" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty-print a header that labels the sub-fields of the encoded
output. This can be used in conjuction with pprint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>prefix</strong> &#8211; printed before the header if specified</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.scalarsToStr">
<code class="descname">scalarsToStr</code><span class="sig-paren">(</span><em>scalarValues</em>, <em>scalarNames=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.scalarsToStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pretty print string representing the return values from
getScalars and getScalarNames().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>scalarValues</strong> &#8211; input values to encode to string</li>
<li><strong>scalarNames</strong> &#8211; optional input of scalar names to convert. If None, gets
scalar names from getScalarNames()</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">string representation of scalar values</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.setFieldStats">
<code class="descname">setFieldStats</code><span class="sig-paren">(</span><em>fieldName</em>, <em>fieldStatistics</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.setFieldStats" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called by the model to set the statistics like min and
max for the underlying encoders if this information is available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fieldName</strong> &#8211; name of the field this encoder is encoding, provided by
multiencoder</li>
<li><strong>fieldStatistics</strong> &#8211; dictionary of dictionaries with the first level being
the fieldname and the second index the statistic ie:
fieldStatistics[&#8216;pounds&#8217;][&#8216;min&#8217;]</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.setLearning">
<code class="descname">setLearning</code><span class="sig-paren">(</span><em>learningEnabled</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.setLearning" title="Permalink to this definition">¶</a></dt>
<dd><p>Set whether learning is enabled.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>learningEnabled</strong> &#8211; whether learning should be enabled</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.setStateLock">
<code class="descname">setStateLock</code><span class="sig-paren">(</span><em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.setStateLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Setting this to true freezes the state of the encoder
This is separate from the learning state which affects changing parameters.
Implemented in subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.base.Encoder.topDownCompute">
<code class="descname">topDownCompute</code><span class="sig-paren">(</span><em>encoded</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.base.Encoder.topDownCompute" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of EncoderResult namedtuples describing the top-down
best guess inputs for each sub-field given the encoded output. These are the
values which are most likely to generate the given encoded output.
To get the associated field names for each of the values, call
getScalarNames().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>encoded</strong> &#8211; The encoded output. Typically received from the topDown outputs
from the spatial pooler just above us.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of EncoderResult namedtuples. Each EncoderResult has
three attributes:<dl class="docutils">
<dt>-# value:         This is the best-guess value for the sub-field</dt>
<dd>in a format that is consistent with the type
specified by getDecoderOutputFieldTypes().
Note that this value is not necessarily
numeric.</dd>
<dt>-# scalar:        The scalar representation of this best-guess</dt>
<dd>value. This number is consistent with what
is returned by getScalars(). This value is
always an int or float, and can be used for
numeric comparisons.</dd>
<dt>-# encoding       This is the encoded bit-array (numpy array)</dt>
<dd>that represents the best-guess value.
That is, if &#8216;value&#8217; was passed to
encode(), an identical bit-array should be
returned.</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="scalar-encoder">
<h2>Scalar Encoder<a class="headerlink" href="#scalar-encoder" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.encoders.scalar.ScalarEncoder">
<em class="property">class </em><code class="descclassname">nupic.encoders.scalar.</code><code class="descname">ScalarEncoder</code><span class="sig-paren">(</span><em>w</em>, <em>minval</em>, <em>maxval</em>, <em>periodic=False</em>, <em>n=0</em>, <em>radius=0</em>, <em>resolution=0</em>, <em>name=None</em>, <em>verbosity=0</em>, <em>clipInput=False</em>, <em>forced=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.scalar.ScalarEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.encoders.base.Encoder" title="nupic.encoders.base.Encoder"><code class="xref py py-class docutils literal"><span class="pre">nupic.encoders.base.Encoder</span></code></a></p>
<p>A scalar encoder encodes a numeric (floating point) value into an array
of bits. The output is 0&#8217;s except for a contiguous block of 1&#8217;s. The
location of this contiguous block varies continuously with the input value.</p>
<p>The encoding is linear. If you want a nonlinear encoding, just transform
the scalar (e.g. by applying a logarithm function) before encoding.
It is not recommended to bin the data as a pre-processing step, e.g.
&#8220;1&#8221; = $0 - $.20, &#8220;2&#8221; = $.21-$0.80, &#8220;3&#8221; = $.81-$1.20, etc. as this
removes a lot of information and prevents nearby values from overlapping
in the output. Instead, use a continuous transformation that scales
the data (a piecewise transformation is fine).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">There are three mutually exclusive parameters that determine the
overall size of of the output. Exactly one of n, radius, resolution must be
set. &#8220;0&#8221; is a special value that means &#8220;not set&#8221;.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>w</strong> &#8211; The number of bits that are set to encode a single value - the
&#8220;width&#8221; of the output signal restriction: w must be odd to avoid
centering problems.</li>
<li><strong>minval</strong> &#8211; The minimum value of the input signal.</li>
<li><strong>maxval</strong> &#8211; The upper bound of the input signal. (input is strictly less if periodic == True)</li>
<li><strong>periodic</strong> &#8211; If true, then the input value &#8220;wraps around&#8221; such that minval = maxval
For a periodic value, the input must be strictly less than maxval,
otherwise maxval is a true upper bound.</li>
<li><strong>n</strong> &#8211; The number of bits in the output. Must be greater than or equal to w</li>
<li><strong>radius</strong> &#8211; Two inputs separated by more than the radius have non-overlapping
representations. Two inputs separated by less than the radius will
in general overlap in at least some of their bits. You can think
of this as the radius of the input.</li>
<li><strong>resolution</strong> &#8211; Two inputs separated by greater than, or equal to the resolution are guaranteed
to have different representations.</li>
<li><strong>name</strong> &#8211; an optional string which will become part of the description</li>
<li><strong>clipInput</strong> &#8211; if true, non-periodic inputs smaller than minval or greater
than maxval will be clipped to minval/maxval</li>
<li><strong>forced</strong> &#8211; if true, skip some safety checks (for compatibility reasons), default false</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Radius and resolution are specified with respect to the input, not output. w
is specified with respect to the output.</p>
</div>
<p><strong>Example: day of week</strong></p>
<div class="highlight-text"><div class="highlight"><pre><span></span>w = 3
Minval = 1 (Monday)
Maxval = 8 (Monday)
periodic = true
n = 14
[equivalently: radius = 1.5 or resolution = 0.5]
</pre></div>
</div>
<p>The following values would encode midnight &#8211; the start of the day</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>monday (1)   -&gt; 11000000000001
tuesday(2)   -&gt; 01110000000000
wednesday(3) -&gt; 00011100000000
...
sunday (7)   -&gt; 10000000000011
</pre></div>
</div>
<p>Since the resolution is 12 hours, we can also encode noon, as</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>monday noon  -&gt; 11100000000000
monday midnt-&gt; 01110000000000
tuesday noon -&gt; 00111000000000
etc.
</pre></div>
</div>
<p><strong>`n` vs `resolution`</strong></p>
<p>It may not be natural to specify &#8220;n&#8221;, especially with non-periodic
data. For example, consider encoding an input with a range of 1-10
(inclusive) using an output width of 5.  If you specify resolution =
1, this means that inputs of 1 and 2 have different outputs, though
they overlap, but 1 and 1.5 might not have different outputs.
This leads to a 14-bit representation like this:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>1 -&gt;  11111000000000  (14 bits total)
2 -&gt;  01111100000000
...
10-&gt;  00000000011111
[resolution = 1; n=14; radius = 5]
</pre></div>
</div>
<p>You could specify resolution = 0.5, which gives</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>1   -&gt; 11111000... (22 bits total)
1.5 -&gt; 011111.....
2.0 -&gt; 0011111....
[resolution = 0.5; n=22; radius=2.5]
</pre></div>
</div>
<p>You could specify radius = 1, which gives</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>1   -&gt; 111110000000....  (50 bits total)
2   -&gt; 000001111100....
3   -&gt; 000000000011111...
...
10  -&gt;                           .....000011111
[radius = 1; resolution = 0.2; n=50]
</pre></div>
</div>
<p>An N/M encoding can also be used to encode a binary value,
where we want more than one bit to represent each state.
For example, we could have: w = 5, minval = 0, maxval = 1,
radius = 1 (which is equivalent to n=10)</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>0 -&gt; 1111100000
1 -&gt; 0000011111
</pre></div>
</div>
<p><strong>Implementation details</strong></p>
<div class="highlight-text"><div class="highlight"><pre><span></span>range = maxval - minval
h = (w-1)/2  (half-width)
resolution = radius / w
n = w * range/radius (periodic)
n = w * range/radius + 2 * h (non-periodic)
</pre></div>
</div>
<dl class="method">
<dt id="nupic.encoders.scalar.ScalarEncoder.closenessScores">
<code class="descname">closenessScores</code><span class="sig-paren">(</span><em>expValues</em>, <em>actValues</em>, <em>fractional=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.scalar.ScalarEncoder.closenessScores" title="Permalink to this definition">¶</a></dt>
<dd><p>See the function description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.scalar.ScalarEncoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>encoded</em>, <em>parentFieldName=''</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.scalar.ScalarEncoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>See the function description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.scalar.ScalarEncoder.encodeIntoArray">
<code class="descname">encodeIntoArray</code><span class="sig-paren">(</span><em>input</em>, <em>output</em>, <em>learn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.scalar.ScalarEncoder.encodeIntoArray" title="Permalink to this definition">¶</a></dt>
<dd><p>See method description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.scalar.ScalarEncoder.getBucketIndices">
<code class="descname">getBucketIndices</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.scalar.ScalarEncoder.getBucketIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>See method description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.scalar.ScalarEncoder.getBucketInfo">
<code class="descname">getBucketInfo</code><span class="sig-paren">(</span><em>buckets</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.scalar.ScalarEncoder.getBucketInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>See the function description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.scalar.ScalarEncoder.getBucketValues">
<code class="descname">getBucketValues</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.scalar.ScalarEncoder.getBucketValues" title="Permalink to this definition">¶</a></dt>
<dd><p>See the function description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.scalar.ScalarEncoder.getDecoderOutputFieldTypes">
<code class="descname">getDecoderOutputFieldTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.scalar.ScalarEncoder.getDecoderOutputFieldTypes" title="Permalink to this definition">¶</a></dt>
<dd><p>[Encoder class virtual method override]</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.scalar.ScalarEncoder.topDownCompute">
<code class="descname">topDownCompute</code><span class="sig-paren">(</span><em>encoded</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.scalar.ScalarEncoder.topDownCompute" title="Permalink to this definition">¶</a></dt>
<dd><p>See the function description in base.py</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="random-distributed-scalar-encoder">
<h2>Random Distributed Scalar Encoder<a class="headerlink" href="#random-distributed-scalar-encoder" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder">
<em class="property">class </em><code class="descclassname">nupic.encoders.random_distributed_scalar.</code><code class="descname">RandomDistributedScalarEncoder</code><span class="sig-paren">(</span><em>resolution</em>, <em>w=21</em>, <em>n=400</em>, <em>name=None</em>, <em>offset=None</em>, <em>seed=42</em>, <em>verbosity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.encoders.base.Encoder" title="nupic.encoders.base.Encoder"><code class="xref py py-class docutils literal"><span class="pre">nupic.encoders.base.Encoder</span></code></a></p>
<p>A scalar encoder encodes a numeric (floating point) value into an array
of bits.</p>
<p>This class maps a scalar value into a random distributed representation that
is suitable as scalar input into the spatial pooler. The encoding scheme is
designed to replace a simple ScalarEncoder. It preserves the important
properties around overlapping representations. Unlike ScalarEncoder the min
and max range can be dynamically increased without any negative effects. The
only required parameter is resolution, which determines the resolution of
input values.</p>
<p>Scalar values are mapped to a bucket. The class maintains a random distributed
encoding for each bucket. The following properties are maintained by
RandomDistributedEncoder:</p>
<p>1) Similar scalars should have high overlap. Overlap should decrease smoothly
as scalars become less similar. Specifically, neighboring bucket indices must
overlap by a linearly decreasing number of bits.</p>
<p>2) Dissimilar scalars should have very low overlap so that the SP does not
confuse representations. Specifically, buckets that are more than w indices
apart should have at most maxOverlap bits of overlap. We arbitrarily (and
safely) define &#8220;very low&#8221; to be 2 bits of overlap or lower.</p>
<p>Properties 1 and 2 lead to the following overlap rules for buckets i and j:</p>
<blockquote>
<div><dl class="docutils">
<dt>If abs(i-j) &lt; w then:</dt>
<dd>overlap(i,j) = w - abs(i-j)</dd>
<dt>else:</dt>
<dd>overlap(i,j) &lt;= maxOverlap</dd>
</dl>
</div></blockquote>
<p>3) The representation for a scalar must not change during the lifetime of
the object. Specifically, as new buckets are created and the min/max range
is extended, the representation for previously in-range sscalars and
previously created buckets must not change.</p>
<dl class="method">
<dt id="nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder.encodeIntoArray">
<code class="descname">encodeIntoArray</code><span class="sig-paren">(</span><em>x</em>, <em>output</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder.encodeIntoArray" title="Permalink to this definition">¶</a></dt>
<dd><p>See method description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder.getBucketIndices">
<code class="descname">getBucketIndices</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder.getBucketIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>See method description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder.getDecoderOutputFieldTypes">
<code class="descname">getDecoderOutputFieldTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder.getDecoderOutputFieldTypes" title="Permalink to this definition">¶</a></dt>
<dd><p>See method description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder.getWidth">
<code class="descname">getWidth</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder.getWidth" title="Permalink to this definition">¶</a></dt>
<dd><p>See method description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder.mapBucketIndexToNonZeroBits">
<code class="descname">mapBucketIndexToNonZeroBits</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.random_distributed_scalar.RandomDistributedScalarEncoder.mapBucketIndexToNonZeroBits" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a bucket index, return the list of non-zero bits. If the bucket
index does not exist, it is created. If the index falls outside our range
we clip it.</p>
<p>&#64;param index The bucket index to get non-zero bits for.
&#64;returns numpy array of indices of non-zero bits for specified index.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="dateencoder">
<h2>DateEncoder<a class="headerlink" href="#dateencoder" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.encoders.date.DateEncoder">
<em class="property">class </em><code class="descclassname">nupic.encoders.date.</code><code class="descname">DateEncoder</code><span class="sig-paren">(</span><em>season=0</em>, <em>dayOfWeek=0</em>, <em>weekend=0</em>, <em>holiday=0</em>, <em>timeOfDay=0</em>, <em>customDays=0</em>, <em>name=''</em>, <em>forced=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.date.DateEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.encoders.base.Encoder" title="nupic.encoders.base.Encoder"><code class="xref py py-class docutils literal"><span class="pre">nupic.encoders.base.Encoder</span></code></a></p>
<p>A date encoder encodes a date according to encoding parameters
specified in its constructor.
The input to a date encoder is a datetime.datetime object. The output
is the concatenation of several sub-encodings, each of which encodes
a different aspect of the date. Which sub-encodings are present, and
details of those sub-encodings, are specified in the DateEncoder
constructor.</p>
<p>Each parameter describes one attribute to encode. By default, the attribute
is not encoded.</p>
<dl class="docutils">
<dt>season (season of the year; units = day):</dt>
<dd>(int) width of attribute; default radius = 91.5 days (1 season)
(tuple)  season[0] = width; season[1] = radius</dd>
<dt>dayOfWeek (monday = 0; units = day)</dt>
<dd>(int) width of attribute; default radius = 1 day
(tuple) dayOfWeek[0] = width; dayOfWeek[1] = radius</dd>
<dt>weekend (boolean: 0, 1)</dt>
<dd>(int) width of attribute</dd>
<dt>holiday (boolean: 0, 1)</dt>
<dd>(int) width of attribute</dd>
<dt>timeOfday (midnight = 0; units = hour)</dt>
<dd>(int) width of attribute: default radius = 4 hours
(tuple) timeOfDay[0] = width; timeOfDay[1] = radius</dd>
</dl>
<p>customDays TODO: what is it?</p>
<p>forced (default True) : if True, skip checks for parameters&#8217; settings; see encoders/scalar.py for details</p>
<dl class="method">
<dt id="nupic.encoders.date.DateEncoder.encodeIntoArray">
<code class="descname">encodeIntoArray</code><span class="sig-paren">(</span><em>input</em>, <em>output</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.date.DateEncoder.encodeIntoArray" title="Permalink to this definition">¶</a></dt>
<dd><p>See method description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.date.DateEncoder.getBucketIndices">
<code class="descname">getBucketIndices</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.date.DateEncoder.getBucketIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>See method description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.date.DateEncoder.getEncodedValues">
<code class="descname">getEncodedValues</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.date.DateEncoder.getEncodedValues" title="Permalink to this definition">¶</a></dt>
<dd><p>See method description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.date.DateEncoder.getScalarNames">
<code class="descname">getScalarNames</code><span class="sig-paren">(</span><em>parentFieldName=''</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.date.DateEncoder.getScalarNames" title="Permalink to this definition">¶</a></dt>
<dd><p>See method description in base.py</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.date.DateEncoder.getScalars">
<code class="descname">getScalars</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.date.DateEncoder.getScalars" title="Permalink to this definition">¶</a></dt>
<dd><p>See method description in base.py</p>
<p>input:          A datetime object representing the time being encoded</p>
<dl class="docutils">
<dt>Returns:        A numpy array of the corresponding scalar values in</dt>
<dd><p class="first">the following order:</p>
<p>[season, dayOfWeek, weekend, holiday, timeOfDay]</p>
<p class="last">Note: some of these fields might be omitted if they were not
specified in the encoder</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="multiencoder">
<h2>MultiEncoder<a class="headerlink" href="#multiencoder" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.encoders.multi.MultiEncoder">
<em class="property">class </em><code class="descclassname">nupic.encoders.multi.</code><code class="descname">MultiEncoder</code><span class="sig-paren">(</span><em>encoderDescriptions=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.multi.MultiEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nupic.encoders.base.Encoder" title="nupic.encoders.base.Encoder"><code class="xref py py-class docutils literal"><span class="pre">nupic.encoders.base.Encoder</span></code></a></p>
<p>A MultiEncoder encodes a dictionary or object with
multiple components. A MultiEncode contains a number
of sub-encoders, each of which encodes a separate component.</p>
<dl class="method">
<dt id="nupic.encoders.multi.MultiEncoder.addMultipleEncoders">
<code class="descname">addMultipleEncoders</code><span class="sig-paren">(</span><em>fieldEncodings</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.multi.MultiEncoder.addMultipleEncoders" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>fieldEncodings &#8211; a dict of dicts, mapping field names to the field params</dt>
<dd>dict.</dd>
</dl>
<p>Each field params dict has the following keys
1) data fieldname that matches the key (&#8216;fieldname&#8217;)
2) an encoder type (&#8216;type&#8217;)
3) and the encoder params (all other keys)</p>
<p>For example,
fieldEncodings={</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;dateTime&#8217;: dict(fieldname=&#8217;dateTime&#8217;, type=&#8217;DateEncoder&#8217;,</dt>
<dd>timeOfDay=(5,5)),</dd>
<dt>&#8216;attendeeCount&#8217;: dict(fieldname=&#8217;attendeeCount&#8217;, type=&#8217;ScalarEncoder&#8217;,</dt>
<dd>name=&#8217;attendeeCount&#8217;, minval=0, maxval=250,
clipInput=True, w=5, resolution=10),</dd>
<dt>&#8216;consumption&#8217;: dict(fieldname=&#8217;consumption&#8217;,type=&#8217;ScalarEncoder&#8217;,</dt>
<dd>name=&#8217;consumption&#8217;, minval=0,maxval=110,
clipInput=True, w=5, resolution=5),</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>would yield a vector with a part encoded by the DateEncoder, 
and to parts seperately taken care of by the ScalarEncoder with the specified parameters. 
The three seperate encodings are then merged together to the final vector, in such a way that
they are always at the same location within the vector.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.encoders.multi.MultiEncoder.getWidth">
<code class="descname">getWidth</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.encoders.multi.MultiEncoder.getWidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the sum of the widths of each fields encoding.</p>
</dd></dl>

</dd></dl>

<div class="section" id="data">
<h3>Data<a class="headerlink" href="#data" title="Permalink to this headline">¶</a></h3>
<div class="section" id="fieldmetatype">
<h4>FieldMetaType<a class="headerlink" href="#fieldmetatype" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="nupic.data.fieldmeta.FieldMetaType">
<em class="property">class </em><code class="descclassname">nupic.data.fieldmeta.</code><code class="descname">FieldMetaType</code><a class="headerlink" href="#nupic.data.fieldmeta.FieldMetaType" title="Permalink to this definition">¶</a></dt>
<dd><p>Public values for the field data types</p>
<dl class="attribute">
<dt id="nupic.data.fieldmeta.FieldMetaType._ALL">
<code class="descname">_ALL</code><em class="property"> = ('string', 'datetime', 'int', 'float', 'bool', 'list', 'sdr')</em><a class="headerlink" href="#nupic.data.fieldmeta.FieldMetaType._ALL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nupic.data.fieldmeta.FieldMetaType.boolean">
<code class="descname">boolean</code><em class="property"> = 'bool'</em><a class="headerlink" href="#nupic.data.fieldmeta.FieldMetaType.boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nupic.data.fieldmeta.FieldMetaType.datetime">
<code class="descname">datetime</code><em class="property"> = 'datetime'</em><a class="headerlink" href="#nupic.data.fieldmeta.FieldMetaType.datetime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nupic.data.fieldmeta.FieldMetaType.float">
<code class="descname">float</code><em class="property"> = 'float'</em><a class="headerlink" href="#nupic.data.fieldmeta.FieldMetaType.float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nupic.data.fieldmeta.FieldMetaType.integer">
<code class="descname">integer</code><em class="property"> = 'int'</em><a class="headerlink" href="#nupic.data.fieldmeta.FieldMetaType.integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nupic.data.fieldmeta.FieldMetaType.isValid">
<em class="property">classmethod </em><code class="descname">isValid</code><span class="sig-paren">(</span><em>fieldDataType</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.data.fieldmeta.FieldMetaType.isValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Check a candidate value whether it&#8217;s one of the valid field data types</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fieldDataType</strong> (<em>str</em>) &#8211; candidate field data type</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if the candidate value is a legitimate field data type value;
False if not</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nupic.data.fieldmeta.FieldMetaType.list">
<code class="descname">list</code><em class="property"> = 'list'</em><a class="headerlink" href="#nupic.data.fieldmeta.FieldMetaType.list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nupic.data.fieldmeta.FieldMetaType.sdr">
<code class="descname">sdr</code><em class="property"> = 'sdr'</em><a class="headerlink" href="#nupic.data.fieldmeta.FieldMetaType.sdr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nupic.data.fieldmeta.FieldMetaType.string">
<code class="descname">string</code><em class="property"> = 'string'</em><a class="headerlink" href="#nupic.data.fieldmeta.FieldMetaType.string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/numenta-logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Encoders</a><ul>
<li><a class="reference internal" href="#encoder">Encoder</a></li>
<li><a class="reference internal" href="#scalar-encoder">Scalar Encoder</a></li>
<li><a class="reference internal" href="#random-distributed-scalar-encoder">Random Distributed Scalar Encoder</a></li>
<li><a class="reference internal" href="#dateencoder">DateEncoder</a></li>
<li><a class="reference internal" href="#multiencoder">MultiEncoder</a><ul>
<li><a class="reference internal" href="#data">Data</a><ul>
<li><a class="reference internal" href="#fieldmetatype">FieldMetaType</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="guide-sample-code.html" title="previous chapter">Hot Gym Code Example</a></li>
      <li>Next: <a href="algorithms.html" title="next chapter">Algorithms</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/encoders.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Numenta.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/encoders.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/numenta/nupic" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>